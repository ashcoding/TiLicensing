/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.sofisoftwarellc.licensing;

import java.util.HashMap;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;

import org.appcelerator.titanium.TiApplication;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;

import android.content.Context;
import android.provider.Settings.Secure;

import com.google.android.vending.licensing.AESObfuscator;
import com.google.android.vending.licensing.LicenseChecker;
import com.google.android.vending.licensing.LicenseCheckerCallback;
import com.google.android.vending.licensing.Policy;
import com.google.android.vending.licensing.ServerManagedPolicy;


@Kroll.module(name="Licensing", id="com.sofisoftwarellc.licensing")
public class LicensingModule extends KrollModule
{
    /**
     * LICENSED means that the server returned back a valid license response
     */
	@Kroll.constant
    public static final int LICENSED = Policy.LICENSED;
    /**
     * NOT_LICENSED means that the server returned back a valid license response
     * that indicated that the user definitively is not licensed
     */
	@Kroll.constant
    public static final int NOT_LICENSED = Policy.NOT_LICENSED;
    /**
     * RETRY means that the license response was unable to be determined ---
     * perhaps as a result of faulty networking
     */
	@Kroll.constant
    public static final int RETRY = Policy.RETRY;

	// Standard Debugging variables
	private static final String TAG = "LicensingModule";
	private static final boolean DEBUG = TiConfig.LOGD;

	private LicenseChecker mChecker;
	private MyLicenseCheckerCallback mLicenseCheckerCallback;
	
	private String mMarketPublicKey;
	private byte[] mSalt;
	private String mDeviceId;
	
    private class MyLicenseCheckerCallback implements LicenseCheckerCallback {
		@Override
		public void allow(int reason) {
            if (DEBUG)
                Log.d(TAG, "MyLicenseCheckerCallback.allow " + reason);

            KrollDict info = new KrollDict();
            
            info.put("response", "allow");
            info.put("reason", reason);
            
    		fireEvent("licenseCheckerEvent", info);
		}

		@Override
		public void dontAllow(int reason) {
            if (DEBUG)
                Log.d(TAG, "MyLicenseCheckerCallback.dontAllow " + reason);

            KrollDict info = new KrollDict();
            
            info.put("response", "dontAllow");
            info.put("reason", reason);
            
    		fireEvent("licenseCheckerEvent", info);
		}

		@Override
		public void applicationError(int errorCode) {
            if (DEBUG)
                Log.d(TAG, "LicenseCheckerCallback.applicationError " + errorCode);

            // This is a polite way of saying the developer made a mistake
            // while setting up or calling the license checker library.
            // Please examine the error code and fix the error.

            KrollDict info = new KrollDict();

            info.put("response", "error");
            info.put("reason", errorCode);
            
    		fireEvent("licenseCheckerEvent", info);

		}
    }

	private static byte[] toByte(String hexString) {
		if (hexString == null)
			return null;
		try {
			int len = hexString.length() / 2;
			byte[] result = new byte[len];
			for (int i = 0; i < len; i++)
				result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2),
						16).byteValue();
			return result;
		} catch (NumberFormatException e) {
			return null;
		}
	}

	public LicensingModule()
	{
		super();
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app)
	{
	}

	// Methods
	@Kroll.method
	public void initialize(@SuppressWarnings("rawtypes") HashMap options)
	{
		String salt = null;
		
		if (options.containsKey("key")) {
			Object o = options.get("key");
			if (o instanceof String)
				mMarketPublicKey = (String) o;
		}
		if (options.containsKey("salt")) {
			Object o = options.get("salt");
			if (o instanceof String)
				salt = (String) o;
		}
		if (options.containsKey("deviceId")) {
			Object o = options.get("deviceId");
			if (o instanceof String) {
				mDeviceId = (String) o;
			} else {
				throw new IllegalArgumentException("deviceId must be a String");
			}
		} else {
			mDeviceId = Secure.getString(TiApplication.getAppRootOrCurrentActivity().getContentResolver(), Secure.ANDROID_ID);
		}
		
		if (mMarketPublicKey == null) {
			throw new IllegalArgumentException("Missing required parameter key");
		}
		if (salt == null) {
			throw new IllegalArgumentException("Missing required parameter salt");
		}
		if (salt.length() != 40) {
			throw new IllegalArgumentException("Salt must be exactly 40 hex digits");
		}
		
		mSalt = toByte(salt);
		if (mSalt == null) {
			throw new IllegalArgumentException("Salt must be exactly 40 hex digits");
		}

        // Construct the LicenseCheckerCallback. The library calls this when done.
        mLicenseCheckerCallback = new MyLicenseCheckerCallback();

        Context context = TiApplication.getAppRootOrCurrentActivity();

        mLicenseCheckerCallback = new MyLicenseCheckerCallback();

        ServerManagedPolicy policy = new ServerManagedPolicy(context,
                new AESObfuscator(mSalt, context.getPackageName(), mDeviceId));

        // Construct the LicenseChecker with a Policy.
        mChecker = new LicenseChecker(
            context, policy,
            mMarketPublicKey
            );
	}

	@Kroll.method
	public void doLicenseCheck()
	{
        if (DEBUG)
            Log.d(TAG, "doLicenseCheck");
        mChecker.checkAccess(mLicenseCheckerCallback);
	}
}

